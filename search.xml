<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>钉钉开放平台-自定义机器人的接入</title>
      <link href="/2022/11/27/ding-ding-zi-ding-yi-ji-qi-ren/"/>
      <url>/2022/11/27/ding-ding-zi-ding-yi-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<h1 id="钉钉自定义机器人的接入"><a href="#钉钉自定义机器人的接入" class="headerlink" title="钉钉自定义机器人的接入"></a>钉钉自定义机器人的接入</h1><h2 id="钉钉自定义机器人"><a href="#钉钉自定义机器人" class="headerlink" title="钉钉自定义机器人"></a>钉钉自定义机器人</h2><h3 id="本地配置文件中修改钉钉机器人token与secret"><a href="#本地配置文件中修改钉钉机器人token与secret" class="headerlink" title="本地配置文件中修改钉钉机器人token与secret"></a>本地配置文件中修改钉钉机器人token与secret</h3><ul><li>修改本地配置文件，修改研磨一、二期的token与secret，可以实现在本地测试钉钉机器人发送消息。<br><img src="/2022/11/27/ding-ding-zi-ding-yi-ji-qi-ren/3.png" alt="图一"></li></ul><h3 id="Service注入钉钉机器人token与secret"><a href="#Service注入钉钉机器人token与secret" class="headerlink" title="Service注入钉钉机器人token与secret"></a>Service注入钉钉机器人token与secret</h3><p><img src="/2022/11/27/ding-ding-zi-ding-yi-ji-qi-ren/2.png" alt="图二"></p><h3 id="Service钉钉机器人发送消息"><a href="#Service钉钉机器人发送消息" class="headerlink" title="Service钉钉机器人发送消息"></a>Service钉钉机器人发送消息</h3><p><img src="/2022/11/27/ding-ding-zi-ding-yi-ji-qi-ren/1.png" alt="图三"></p><h3 id="添加钉钉机器人"><a href="#添加钉钉机器人" class="headerlink" title="添加钉钉机器人"></a>添加钉钉机器人</h3><ul><li>在钉钉中添加机器人时，注意安全设置中ip字段等相关配置。完成安全设置后，复制出机器人的Webhook地址，可用于向这个群发送消息，格式如下：<pre class="line-numbers language-none"><code class="language-none">https://oapi.dingtalk.com/robot/send?access_token=XXXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="使用钉钉机器人"><a href="#使用钉钉机器人" class="headerlink" title="使用钉钉机器人"></a>使用钉钉机器人</h3><ul><li><p>获取到Webhook地址后，用户可以向这个地址发起HTTP POST 请求，即可实现给该钉钉群发送消息。</p></li><li><p>PS：</p></li><li><p>1.发起POST请求时，必须将字符集编码设置成UTF-8。</p></li><li><p>2.每个机器人每分钟最多发送20条。消息发送太频繁会严重影响群成员的使用体验，大量发消息的场景 (譬如系统监控报警) 可以将这些信息进行整合，通过markdown消息以摘要的形式发送到群里。</p></li></ul><h3 id="消息类型及数据格式"><a href="#消息类型及数据格式" class="headerlink" title="消息类型及数据格式"></a>消息类型及数据格式</h3><ul><li>1.text类型</li><li>2.link类型</li><li>3.markdown类型</li><li>4.整体跳转ActionCard类型</li><li>5.独立跳转ActionCard类型</li><li>6.FeedCard类型</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>轴承清洗测试及问题修改</title>
      <link href="/2022/11/25/zhou-cheng-xu-qiu-ce-shi-ji-wen-ti-xiu-gai/"/>
      <url>/2022/11/25/zhou-cheng-xu-qiu-ce-shi-ji-wen-ti-xiu-gai/</url>
      
        <content type="html"><![CDATA[<h1 id="轴承清洗测试及问题修改"><a href="#轴承清洗测试及问题修改" class="headerlink" title="轴承清洗测试及问题修改"></a>轴承清洗测试及问题修改</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ul><li>轴承座号存在父节点和子节点，在调用之前写的方法的时候取得是轴承座号的父节点，但是根据这个父节点无法在清洗记录里查找到数据，一个父节点可能对应的是两个子节点或者四个父节点。</li></ul><h3 id="解决问题思路："><a href="#解决问题思路：" class="headerlink" title="解决问题思路："></a>解决问题思路：</h3><ul><li>在装配记录中轴承座号是以父节点存在的，但清洗的时候是根据<code>classify</code>获取到轴承座号对应的子节点来进行清洗记录的创建，所以可以把调用的方法放在循环创建子节点对应的方法中，循环在<code>cleanfrequency</code>创建或者新增子节点的数据。</li></ul><h3 id="解决措施："><a href="#解决措施：" class="headerlink" title="解决措施："></a>解决措施：</h3><p><img src="/2022/11/25/zhou-cheng-xu-qiu-ce-shi-ji-wen-ti-xiu-gai/1.png" alt="图1"></p><ul><li>红框1：根据父节点查找到<code>classify</code>中对应的子节点，然后进行清洗记录的新建</li><li>红框2：调用<code>CopyCleanout</code>方法获取子节点进行在<code>cleanfrequency</code>表中的创建或更新</li><li>红框3：原来是想要根据子节点获取到对应的父节点，再调用<code>CopyCleanout</code>方法，但是牵扯到轴承更换的问题。轴承更换是在清洗记录里对子节点的轴承进行更换，后续要根据是否更换(isreplace)来对清洗次数和使用里程进行关操作，所以这部分代码不适用。</li></ul><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="遇到的问题：-1"><a href="#遇到的问题：-1" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ul><li>轴承更换之后根据需求要将此轴承对应的清洗记录清空，将该轴承对应的使用里程清空。</li></ul><h3 id="解决问题思路：-1"><a href="#解决问题思路：-1" class="headerlink" title="解决问题思路："></a>解决问题思路：</h3><ul><li>在轴承更换之后，将<code>cleanfrequency</code>中该轴承对应的清洗记录次数清零，轴承的使用里程稍微麻烦一点，在轴承清洗提示的时候轴承的使用里程是从<code>assembly</code>中取出来，然后赋值给明细表，清洗记录里边的轴承使用里程是有明细表获取到的，所以在轴承更换之后要清空的是<code>assembly</code>中的使用里程。</li><li>首先在<code>cleanout</code>中有一个<code>detailid</code>，根据这个id可以在明细表中查询到对应的数据，然后明细表中有一个<code>assemblyid</code>字段，根据这个字段又可以在<code>assembly</code>中查询到对应的数据，最后进行对使用里程的清零操作就可以了。</li></ul><h3 id="解决措施：-1"><a href="#解决措施：-1" class="headerlink" title="解决措施："></a>解决措施：</h3><p><img src="/2022/11/25/zhou-cheng-xu-qiu-ce-shi-ji-wen-ti-xiu-gai/2.png" alt="图2"></p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ul><li>最初要修改的使用里程错认为明细表里的使用里程，整理了一下根据现有信息从明细表里查询数据的方法。</li></ul><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><pre class="line-numbers language-none"><code class="language-none">AssemblyDetailS assemblyDetailS = new AssemblyDetailS(); assemblyDetailS.setId(cleanout.getDetailid()); List&lt;AssemblyDetail&gt; assemblydlist = assemblyDetailS.fetchList(assemblyDetailDao, AssemblyDetail.class); AssemblyDetail assemblyDetail = null; if(assemblydlist!=null &amp;&amp; assemblydlist.size()==1) { assemblyDetail = assemblydlist.get(0); } if(assemblyDetail!=null) { assemblyDetail.setUsemileage(String.valueOf(0)); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><pre class="line-numbers language-none"><code class="language-none">List&lt;AssemblyDetail&gt; assemblydlist = assemblyDetailDao.search(cleanout.getDetailid());AssemblyDetail assemblyDetail = null; if(assemblydlist!=null &amp;&amp; assemblydlist.size()==1) { assemblyDetail = assemblydlist.get(0);}if(assemblyDetail!=null) { assemblyDetail.setUsemileage(String.valueOf(0));}         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><pre class="line-numbers language-none"><code class="language-none">AssemblyDetail findshuju2 = assemblyDetailDao.findOne(cleanout.getDetailid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><h3 id="遇到的问题：-2"><a href="#遇到的问题：-2" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ul><li>怎么样获取轴承更换之后轴承的清洗次数？在轴承更换之后，清洗次数以及清零。但我写的sql语句是根据轴承座号获取对应清洗记录里的数据有多少条，再给<code>cleanfrequency</code>中的清洗次数赋值，但是在轴承更换之后，之前的清洗数据还会存在记录表里。</li></ul><h3 id="解决问题思路：-2"><a href="#解决问题思路：-2" class="headerlink" title="解决问题思路："></a>解决问题思路：</h3><ul><li>新建的这张数据库表就是要对创建的数据进行一个操作，从一开始调用<code>CopyCleanout</code>方法，若表中没有该轴承座号对应的数据，那么久新创建一条，如果已有该轴承座号对应的数据那么在进行判断轴承是否更换过，若更换过则给清洗次数和使用里程清零，若没有则直接对查出来的数据进行清洗次数的加1。</li></ul><h3 id="解决措施：-2"><a href="#解决措施：-2" class="headerlink" title="解决措施："></a>解决措施：</h3><pre class="line-numbers language-none"><code class="language-none">cleanfrequencyService.CopyCleanout(bearingnumber,cleanout);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/11/25/zhou-cheng-xu-qiu-ce-shi-ji-wen-ti-xiu-gai/3.png" alt="图三"></p><ul><li>调用的方法这里除了要传一个轴承座号之外，还需要传一个<code>isreplace</code>字段，所以增加了一个入参，而在清洗操作是调用的方法只需要传一个轴承座号，所以另一个参数置空。</li><li>红框2是初始化数据用到的方法，一旦要清洗的轴承座号数据在<code>cleanfrequency</code>中存在，那么只需要在清洗操作调用红框1方法是给<code>cleantimes</code>增1。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>轴承清洗提示需求</title>
      <link href="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/"/>
      <url>/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>在研磨管理模块中，轴承在维护两个周期后，维护的里程不变，轴承长时间在工作中容易在使用中疲劳损坏。因此该项需求为在轴承使用的两个周期后，1200工作辊轴承维护里程12000km，变为10000km；1200中间辊轴承维护里程15000km，变为12000km；1380工作辊轴承维护里程18000km，变为13000km；1380中间辊轴承维护里程18000km，变为13000km；轴承更换后，从头计算里程数。</p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="1-分析需求，梳理逻辑"><a href="#1-分析需求，梳理逻辑" class="headerlink" title="1.分析需求，梳理逻辑"></a>1.分析需求，梳理逻辑</h2><ul><li>该需求是想在原来清洗提示的基础上实现轴承在运转两个周期后，缩小轴承清洗提示的里程，那么就需要一个字段来统计某个轴承在进行更换之前的清次数</li><li>该需求需要在轴承更换之后从头计算里程数，但是如果直接在现有的数据库表中操作势必会污染其他的数据，所以选择新建一张物理表。</li><li>轴承往往是成对使用所以在数据字典中每一个对应编号下的轴承都是成对出现，辊又分为工作辊和中间辊，注意工作辊对应有上辊和下辊。所以我们在进行需求开发的时候是通过轴承座号来查找对应的中间辊和工作辊。</li></ul><h2 id="2-确定字段"><a href="#2-确定字段" class="headerlink" title="2.确定字段"></a>2.确定字段</h2><ul><li>轴承清洗提示这个需求我们需要的字段有必须的id、version，查询辊对应的轴承座号，以及新增的统计轧辊统共清洗字数的字段,其他字段不牵扯所以省略。</li></ul><h3 id="1-设计物理表，编写实体"><a href="#1-设计物理表，编写实体" class="headerlink" title="1.设计物理表，编写实体"></a>1.设计物理表，编写实体</h3><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/1.png" alt="物理表"></p><ul><li>注意所标识ID，可自动生成。</li></ul><h2 id="3-设计Service方法"><a href="#3-设计Service方法" class="headerlink" title="3.设计Service方法"></a>3.设计Service方法</h2><h3 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h3><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/2.png" alt="Service-新建数据并保存"><br><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/3.png" alt="Dao-根据轴承座号查询出对应轧辊的清洗次数"></p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/4.png" alt="“清洗”操作调用该方法"></p><ul><li>1.根据第一部分代码可以得出已经是筛选出了不在清洗进程的数据，所以根据这部分数据我可以获取到我想要的轴承座号。</li><li>2.根据得到的轴承座号去调用我所写的方法，获取到每个轴承座号对应的轧辊的清洗次数。</li><li>PS：在轧辊持续工作的进程中，肯定会有部分轧辊已经存在所建的数据表中，那么这部分数据不需要进行新建记录，而是更新。</li></ul><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/5.png" alt="Dao"></p><ul><li>利用<code>dao</code>层来编写查询和更新语句。</li></ul><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/6.png" alt="Service"></p><ul><li>通过编写<code>sql</code>语句通过轴承座号来查询数据库中的数据，如果该轴承座号已存在与数据库表，那么查询他对应的轧辊清洗记录，并通过生气了语句进行更新操作，若不存在该条数据，则进行新建数据。</li></ul><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/7.png"></p><ul><li>在轴承清洗提示业务代码中新增sql语句用来查询<code>cleanfrequency</code>表中的清洗次数并通过该字段进行判断轴承提示里程的变更。</li><li>在轴承进行清洗提示代码中添加同样的判断。</li><li>在轴承确定更换之后根据轴承座号将<code>cleanfrequency</code>对应的数据删除，装配记录明细表中对应的使用里程置零。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-需要注意的问题"><a href="#1-需要注意的问题" class="headerlink" title="1.需要注意的问题"></a>1.需要注意的问题</h3><p><img src="/2022/11/18/zhou-cheng-qing-xi-ti-shi-xu-qiu/8.png" alt="语法格式"></p><ul><li>编写的<code>sql</code>语句无法调用，但在数据库上可以<code>update</code>，原因是等号左右两边没有留下空格，属于语法错误。</li></ul><h3 id="2-需求总结"><a href="#2-需求总结" class="headerlink" title="2.需求总结"></a>2.需求总结</h3><p>在学习新的业务代码的时候要注意方法或者某些业务代码有写入的地方一定就会有读取的地方，无论是新建或者更新都是在写入，都会有对应业务要调取的地方。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>调用本地未启用的dubbo服务</title>
      <link href="/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/"/>
      <url>/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="查看报表时，前端无法返回数据，后端报错"><a href="#查看报表时，前端无法返回数据，后端报错" class="headerlink" title="查看报表时，前端无法返回数据，后端报错"></a>查看报表时，前端无法返回数据，后端报错</h2><pre class="line-numbers language-none"><code class="language-none">﻿java.lang.RuntimeException: org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is java.lang.reflect.UndeclaredThrowableExceptionorg.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is java.lang.reflect.UndeclaredThrowableExceptionat org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:431)at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:447)at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:277)at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:656)at dnn.module.storage.service.WareHouseService$$EnhancerBySpringCGLIB$$ee391476.findOne(&lt;generated&gt;)at dnn.module.storage.dubbo.WareHouseDsiImpl.findOne(WareHouseDsiImpl.java:29)at com.alibaba.dubbo.common.bytecode.Wrapper38.invokeMethod(Wrapper38.java)at com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$1.doInvoke(JavassistProxyFactory.java:46)at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:72)at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53)at dnn.framework.dubbo.DubboProviderFilter.invoke(DubboProviderFilter.java:41)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at io.seata.integration.dubbo.alibaba.AlibabaDubboTransactionPropagationFilter.invoke(AlibabaDubboTransactionPropagationFilter.java:68)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(ExceptionFilter.java:64)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at com.alibaba.dubbo.rpc.filter.TimeoutFilter.invoke(TimeoutFilter.java:42)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter.invoke(TraceFilter.java:78)at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:91)at com.alibaba.dubbo.rpc.filter.ContextFilter.invoke(<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><ul><li>查看报错原因，里边有一条提示<br><img src="/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/1.png" alt="报错原因提示"></li></ul><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><ul><li>在调用dubbo服务的时候，对应的<code>dubbo</code>服务出错，所以报错了。</li></ul><hr><h1 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h1><ul><li>1.首先要在<code>C:\Users\王美娜</code>类似这种相同的路径下面放入一个<code>dubbo-resolve.properties</code>文件。</li><li>2.在<code>workspace</code>中该项目的同名文件。<br><img src="/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/2.png" alt="同名文件相关设置"></li><li>3.设置该文件的dubbo地址，<code>127.0.0.1</code>表示本地的地址，后边的端口号<code>30137</code>为提供项目所对应的<code>dubbo协议接口</code>，该端口可以从项目<code>application-local.properties</code>文件中获得。</li><li>4.修改完相关的配置后，一定要重启提供服务与被服务的两个项目。</li></ul><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ul><li>1.注意配置时要根据报错提示来进行配置，无关的不用配置，相关需要进行配置的<code>dubbo</code>会在报错日志中进行提示。</li><li>2.寻找项目配置该<code>dubbo</code>时，一定不要盲目寻找项目进行配置，提供dubbo的项目一定要含有日志中所报错的dubbo服务。</li></ul><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="1-类似错误"><a href="#1-类似错误" class="headerlink" title="1.类似错误"></a>1.类似错误</h2><p><img src="/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/3.JPG" alt="类似错误"></p><h2 id="2-项目启动错误"><a href="#2-项目启动错误" class="headerlink" title="2.项目启动错误"></a>2.项目启动错误</h2><h3 id="useSSL-x3D-false"><a href="#useSSL-x3D-false" class="headerlink" title="useSSL=false"></a>useSSL=false</h3><pre class="line-numbers language-none"><code class="language-none">Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+,5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>原因是<code>MySQL</code>在高版本需要指明是否进行<code>SSL</code>连接。<pre class="line-numbers language-none"><code class="language-none">SSL协议提供服务主要：      1）认证用户服务器，确保数据发送到正确的服务器； 　　 .     2）加密数据，防止数据传输途中被窃取使用；     3）维护数据完整性，验证数据在传输过程中是否丢失； 当前支持SSL协议两层：  SSL记录协议（SSL Record Protocol）：建立靠传输协议（TCP）高层协议提供数据封装、压缩、加密等基本功能支持   SSL握手协议（SSL Handshake Protocol）：建立SSL记录协议用于实际数据传输始前通讯双进行身份认证、协商加密   算法、 交换加密密钥等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="解决措施及useSSL-x3D-false与useSSL-x3D-true的区别。"><a href="#解决措施及useSSL-x3D-false与useSSL-x3D-true的区别。" class="headerlink" title="解决措施及useSSL=false与useSSL=true的区别。"></a>解决措施及useSSL=false与useSSL=true的区别。</h4><p>在<code>mysql</code>进行连接的时候,如果<code>mysql</code>的版本是<code>5.7</code>之后的版本必须要加上<code>useSSL=false</code>,<code>mysql5.7</code>以及之前的版本则不用进行添加<code>useSSL=false</code>，会默认为<code>false</code>，一般情况下都是使用<code>useSSL=false</code>，尤其是在将项目部署到<code>linux</code>上时，一定要使用<code>useSSL=false</code>！！！，<code>useSSL=true</code>是进行安全验证，一般通过证书或者令牌什么的，<code>useSSL=false</code>就是通过账号密码进行连接，通常使用<code>useSSL=false</code>.</p><h2 id="3-dubbo错误"><a href="#3-dubbo错误" class="headerlink" title="3.dubbo错误"></a>3.dubbo错误</h2><p><img src="/2022/11/18/diao-yong-ben-di-wei-qi-dong-de-dubbo-fu-wu/4.png"></p><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>dubbo只注册：设置为<code>false</code>为禁止注册。</p><h3 id="解决措施-1"><a href="#解决措施-1" class="headerlink" title="解决措施"></a>解决措施</h3><p>将<code>false</code>改为<code>true</code>。</p><h3 id="dubbo只注册"><a href="#dubbo只注册" class="headerlink" title="dubbo只注册"></a>dubbo只注册</h3><ul><li><p>只订阅的含义就是当前应用只会消费所需接口，就算有提供接口，也不会注册到注册中心。</p></li><li><p>配置形式：默认值都是<code>true</code>，<code>false</code> 表示禁止注册</p> <pre class="line-numbers language-none"><code class="language-none"> dubbo.provider.register=falsedubbo.registry.register=falsedubbo.protocol.register=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>上面三个配置都会禁止注册当前应用的所有接口到注册中心，即使我们在接口上显示<code>@DubboService(register = true)</code>,也不会注册接口到注册中心。</p><hr><h1 id="知识更新"><a href="#知识更新" class="headerlink" title="知识更新"></a>知识更新</h1><ul><li><code>dubbo</code>设置成<code>false</code>表达的含义为不主动对外暴露，是为了避免本地对业务逻辑修改时，如果本地的<code>dubbo</code>服务对外暴露，由于注册中心分配调用的提供者无法指定，因为会导致其他人调用到自己的<code>dubbo</code>服务。设置成不暴露后依旧可以通过直接指定<code>ip：端口</code>调起。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查询数据系列问题</title>
      <link href="/2022/11/12/cha-xun-shu-ju-xi-lie-wen-ti/"/>
      <url>/2022/11/12/cha-xun-shu-ju-xi-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="查询数据系列问题"><a href="#查询数据系列问题" class="headerlink" title="查询数据系列问题"></a>查询数据系列问题</h1><h2 id="使用过的查询方法"><a href="#使用过的查询方法" class="headerlink" title="使用过的查询方法-"></a>使用过的查询方法-</h2><h3 id="fetchDate"><a href="#fetchDate" class="headerlink" title="fetchDate"></a>fetchDate</h3><pre class="line-numbers language-none"><code class="language-none">JsonObject fetchData = detailS.fetchData(DetailDao, Detail.class,new CustomFormatRow&lt;Detail&gt;() {@Overridepublic void formatRow(Detail detail, SearchRow row) {}                    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fetchList"><a href="#fetchList" class="headerlink" title="fetchList"></a>fetchList</h3><pre class="line-numbers language-none"><code class="language-none">List&lt;Proplan&gt; proplanlist = proplanS.fetchList(proplanDao, Proplan.class);Proplan proplan = null;if(proplanlist!=null &amp;&amp; proplanlist.size()==1) {proplan  = proplanlist.get(0);}    if(proplan!=null) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h3><pre class="line-numbers language-none"><code class="language-none">for (int i = 0; i &lt; selectRows.size(); i++) {DxRecord dxRecord2 = dxRecordDao.findOne(selectRows.get(i));    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">CoatingPlan paintingPlan = planService.findOne(dxDetail.getProplanid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DxDetail undetail = dxuncoilDao.findOne(t.getDxdetailid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><pre class="line-numbers language-none"><code class="language-none">@Query(value="SELECT beizhu FROM upcoiler WHERE gunum = ?1 LIMIT 1 ",nativeQuery=true)String getSxsjrecord(String rzgunum);String sxsjbeizhu = sxproductDetailDao.getSxsjrecord(detail.getRzgunum());row.add("sxsjrecord", sxsjbeizhu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public DxRecord findByGunum(String gunum) {return dxDao.findByGunum(gunum);DxRecord dxRecord = dxRecordService.findByGunum(t.getDxgunum());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在lygz报表中出现的问题"><a href="#在lygz报表中出现的问题" class="headerlink" title="在lygz报表中出现的问题"></a>在lygz报表中出现的问题</h2><ul><li>在进行从<code>plan</code>里筛选数据时，第一次写的是用<code>findOne(id)</code>进行数据查询，但是<code>plan</code>里边的<code>id</code>对应的是生产明细中的<code>proplanid</code>，而<code>findOne()</code>这个方法是要通过主键进行筛选，很显然这里不能调用<code>findOne()</code>方法。</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ul><li>由于所出现的问题，所以在<code>lygz</code>报表中调用了查询类的<code>fetchList</code>方法来取出相对应的数据。</li><li>PS: 也可以通过<code>Dao</code>层的查询语句来进行数据的获取，要注意在<code>Dao</code>里拼写<code>Sql</code>语句过多会影响数据的查询速度。<br><code>fetchDate</code>返回的数据为<code>JSON</code>格式。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li><code>findById</code> 通过<code>id</code>查找,没查询到就返回<code>null</code></li><li><code>getOne</code> 通过<code>id</code>查找 采用懒加载 使用时才真正去查库.若<code>id</code>未查询到会异常<code>EntityNotFoundException</code>.</li><li><code>findOne</code>所查询的结果必须是只包含一条结果,否则会报如下异常<pre class="line-numbers language-none"><code class="language-none">org.springframework.dao.IncorrectResultSizeDataAccessException: query did not return a unique result: 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>findAllById</code> 通过<code>id</code>查询多个 若未查询到则返回空集合</li><li><code>findAllById</code> 通过<code>id</code>查询多个 若未查询到则返回空集合</li><li><code>save</code> 保存 需要配置主键自增策略 <code>@Transactional</code>注解要去掉不然会回滚数据添加失败!</li><li><code> delete</code> 删除 删除没有返回值</li><li><code>deleteALL</code> 删除所有数据 会执行两条<code>sql</code> 先查出所有<code>id</code> 然后根据<code>id</code>一条条的删除.慎用避免使用无参清空数据</li><li><code>count</code> 查询数量 无参的方法会返回所有的记录</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 需求，学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中 Boolean 和 boolean的区别</title>
      <link href="/2022/11/12/boolean-yu-boolean-de-qu-bie/"/>
      <url>/2022/11/12/boolean-yu-boolean-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中-Boolean-和-boolean的区别"><a href="#Java-中-Boolean-和-boolean的区别" class="headerlink" title="Java 中 Boolean 和 boolean的区别"></a>Java 中 Boolean 和 boolean的区别</h1><hr><h2 id="开发过程中遇到的问题"><a href="#开发过程中遇到的问题" class="headerlink" title="开发过程中遇到的问题"></a>开发过程中遇到的问题</h2><!-- ![](./Boolean%E4%B8%8Eboolean%E7%9A%84%E5%8C%BA%E5%88%AB/1.png) --><pre class="line-numbers language-none"><code class="language-none">/***** * 是否进行规格修改 */    private Boolean ischangespec=false;public Boolean getIschangespec() {return ischangespec;}public void setIschangespec(Boolean ischangespec) {this.ischangespec = ischangespec;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增加以上字段之后，经过改轧的数据不会在生产明细中显示。</p><hr><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><ul><li><code>boolean</code> 是 <code>Java</code> 的基本数据类型，<code>Boolean</code> 是 <code>Java</code> 的一个类。<code>boolean</code> 类型会在<code>“赋零值”</code>阶段给属性赋 <code>false</code>。而 <code>Boolean</code> 是一个类，会在<code>“赋零值”</code>阶段给对象赋 <code>null</code>。如果是静态属性，会在类加载时被赋值。如果是普通类属性，会在实例化对象时赋值。</li><li>简单的来说，如果<code>Boolean</code>不设置默认值那么其默认为<code>空</code>。如果<code>boolean</code>不设置默认值那么其默认为<code>false</code></li></ul><h3 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h3><ul><li>加载：根据类的全名获取类的二进制字节流，将类加载进内存并在堆中生成一个代表这个类的 <code>Class</code> 对象，作为方法区数据的访问入口。</li><li>验证：验证 <code>class</code> 文件中的字节流是否符合 <code>JVM</code> 规范。</li><li>准备：在方法区中为类的静态属性分配内存，并初始化默认值（<code>boolean </code>的默认值是 <code>false</code>，<code>Boolean </code>的默认值是 <code>null</code>）。</li><li>解析：将常量池中的符号引用转化为直接引用，可以理解为对象引用转成指针。</li><li>初始化：真正开始执行类中的代码，静态属性赋值和静态块。</li></ul><h3 id="对象实例化过程："><a href="#对象实例化过程：" class="headerlink" title="对象实例化过程："></a>对象实例化过程：</h3><ul><li>检查类是否已经被加载（双亲委派）</li><li>给对象分配内存空间（指针碰撞）</li><li>零值初始化（<code>false / null</code>）</li><li>设置对象头（对象分代年龄等信息）</li><li>执行<code>&lt;init&gt;</code>方法（属性初始化，语句块和构造方法）<br>所以说，<code>Boolean</code>只是被加载了，还没有被实例化，在被实例化之前并没有分配内存，所以是 <code>null</code></li></ul><h3 id="风险点："><a href="#风险点：" class="headerlink" title="风险点："></a>风险点：</h3><img src="https://img-blog.csdnimg.cn/20200513232440432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21raWlfaG9uZw==,size_16,color_FFFFFF,t_70#pic_center"><hr><h2 id="解决问题措施："><a href="#解决问题措施：" class="headerlink" title="解决问题措施："></a>解决问题措施：</h2><ul><li>将<code>ischangespec</code>  字段的默认值删掉，默认值为<code>null</code>。</li><li>将默认值删掉之后，重启项目发现生产明细中不能显示的数据可以正常显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java，学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab解决报错1</title>
      <link href="/2022/11/10/gitlab-jie-jue-bao-cuo-1/"/>
      <url>/2022/11/10/gitlab-jie-jue-bao-cuo-1/</url>
      
        <content type="html"><![CDATA[<h1 id="gitlab报错"><a href="#gitlab报错" class="headerlink" title="gitlab报错"></a>gitlab报错</h1><hr><h2 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h2><p><img src="/2022/11/10/gitlab-jie-jue-bao-cuo-1/1.png"></p><!-- <img src="gitlab解决报错1/日志分析.png"> --><hr><h3 id="分析错误原因"><a href="#分析错误原因" class="headerlink" title="分析错误原因"></a>分析错误原因</h3><p>根据日志可以分析出来，在我进行<code>thirdproduct</code>项目向<code>master</code>合并之前，其他同事已经提交过一次项目了，但在我提交之前没有重新拉取该项目，导致流水线在跑的时候在我的项目中找不到对应的方法所以报错。</p><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><p>查找到错误出现的原因之后得出，我<code>远端</code>的<code>practice</code>和<code>master</code>中的代码不一致，所以要拉取<code>master</code>的最新代码对<code>本地practice</code>进行更新，然后将更新之后的<code>practice</code>推送至<code>远端</code>的<code>practice</code>，这样远端提交过得 <code>practice</code>分支里边的代码就和<code>master</code>中的代码一致了，然后再进行<code>retry</code>。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/10/gitlab-jie-jue-bao-cuo-1/2.png"></h2><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ul><li>我本次提交的为<code>dlx</code>的标签上的修改，文件为<code>html</code>文件，所以在<code>pre</code>流水线跑完报错之后，<code>“合并”</code>按钮是红色的，不是灰色的，这是因为我所提交的不是业务代码，所以允许被<code>强制提交</code>，但是<code>不可以</code>进行强制提交。</li><li>注意进行推送的时候，一定要清楚地知道<code>“为什么要推送”</code>，这次我推送的原因是为了更新远端的<code>practice</code>，所以选择<code>practice</code>。若是选择<code>master</code>则会覆盖<code>远端master</code>的代码。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> gitlab，学习，报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.31-11.4周记</title>
      <link href="/2022/11/07/10-31-11-4-zhou-ji/"/>
      <url>/2022/11/07/10-31-11-4-zhou-ji/</url>
      
        <content type="html"><![CDATA[<p>总结：这一周的感觉是比较充实的，包括功能的设计、功能的bug修改以及关于dlx、ct标签的设计相关的知识都学习到了很多。<br>第一，要注意的是在设计相关报表或者功能实现的前提之下一定是要跟用户沟通清楚流程是怎样的，数据是应该怎么样去获取的，开发的过程中如果遇到了什么流程或者相关字段取值的问题一定要以和用户沟通为主。这次的lygztjbb就做的不是很好，其实当用户在修改gg里进行改动的时候就已经算是gz了，在proplan里对应的typeid=4其实可以叫做该规，那我对应的取值逻辑的主次就搞反了，后者的sql语句是正确的。<br>       1.select lz.* from  proplan pro<br>left JOIN lzproductiondetail lz on  lz.proplanid=pro.id<br>where pro.producttypeid=4<br>        2.select lz.* from  lzproductiondetail lz<br>left JOIN proplan pro on  lz.proplanid=pro.id<br>where lz.ischangespec=1<br>第二，在开发中遇到了几次空指针的问题，有的较为简单，只需要加一个判空就可以解决。但是有部分问题时调用了其他方法造成的，那么控制台的报错就会出现在对应的方法上，这个时候就要去梳理清楚逻辑，确定这个方法调用的字段有没有可能存在“空”的情况，如果存在那么加上判空条件，注意一下某个字段的取值可能有几个字段组成的，那么就要考虑这几个字段是否为空，必要的时候要加上一个&amp;&amp;。比如在StorageAndLableService中，在获取dlx——pinming和grade时，其实是调用了一个方法对这两个数据的取值又进行了转化，那么转换方法报空就是因为字段取值可能存在空的情况。<br>第三，在进行某个字段要截取取值时，一定要注意分隔符，像“+”、“*”等这种符号是会出现在正则表达式里的，解决方法就是要加一个“/”或者“[]”。<br>第四，要注意在本地数据库里出现某字段数据id存在，但对应字段数据不存在时，可以去只读的正式数据库里进行查找，若正式数据库里存在数据，那么就要把它insert到本地数据库里，这里要注意，insert到本地的数据库为中台本地数据库，比如goodsCode这个字段，因为项目的数据查询是要去调取dubbo的。<br>第五，学习到了mobile端打包升级的知识，需要注意：1.终端中的powershell要换成wsl，因为我们是要通过wsl进行打包。2.右下角的行尾序列要将CRLF换成LF。3.app.compotent.ts line:34中有个login，打包为apk时要放开，打包web时要注掉。打包语句举例：“./app-update.sh test”。前端的打包涉及到了Linux语句，要对Linux基础知识学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习、需求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/07/hello-world/"/>
      <url>/2022/11/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
