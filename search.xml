<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>查询数据系列问题</title>
      <link href="/2022/11/12/cha-xun-shu-ju-xi-lie-wen-ti/"/>
      <url>/2022/11/12/cha-xun-shu-ju-xi-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="查询数据系列问题"><a href="#查询数据系列问题" class="headerlink" title="查询数据系列问题"></a>查询数据系列问题</h1><h2 id="使用过的查询方法"><a href="#使用过的查询方法" class="headerlink" title="使用过的查询方法-"></a>使用过的查询方法-</h2><h3 id="fetchDate"><a href="#fetchDate" class="headerlink" title="fetchDate"></a>fetchDate</h3><pre class="line-numbers language-none"><code class="language-none">JsonObject fetchData = detailS.fetchData(DetailDao, Detail.class,new CustomFormatRow&lt;Detail&gt;() {@Overridepublic void formatRow(Detail detail, SearchRow row) {}                    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fetchList"><a href="#fetchList" class="headerlink" title="fetchList"></a>fetchList</h3><pre class="line-numbers language-none"><code class="language-none">List&lt;Proplan&gt; proplanlist = proplanS.fetchList(proplanDao, Proplan.class);Proplan proplan = null;if(proplanlist!=null &amp;&amp; proplanlist.size()==1) {proplan  = proplanlist.get(0);}    if(proplan!=null) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h3><pre class="line-numbers language-none"><code class="language-none">for (int i = 0; i &lt; selectRows.size(); i++) {DxRecord dxRecord2 = dxRecordDao.findOne(selectRows.get(i));    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">CoatingPlan paintingPlan = planService.findOne(dxDetail.getProplanid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DxDetail undetail = dxuncoilDao.findOne(t.getDxdetailid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><pre class="line-numbers language-none"><code class="language-none">@Query(value="SELECT beizhu FROM upcoiler WHERE gunum = ?1 LIMIT 1 ",nativeQuery=true)String getSxsjrecord(String rzgunum);String sxsjbeizhu = sxproductDetailDao.getSxsjrecord(detail.getRzgunum());row.add("sxsjrecord", sxsjbeizhu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public DxRecord findByGunum(String gunum) {return dxDao.findByGunum(gunum);DxRecord dxRecord = dxRecordService.findByGunum(t.getDxgunum());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在lygz报表中出现的问题"><a href="#在lygz报表中出现的问题" class="headerlink" title="在lygz报表中出现的问题"></a>在lygz报表中出现的问题</h2><ul><li>在进行从<code>plan</code>里筛选数据时，第一次写的是用<code>findOne(id)</code>进行数据查询，但是<code>plan</code>里边的<code>id</code>对应的是生产明细中的<code>proplanid</code>，而<code>findOne()</code>这个方法是要通过主键进行筛选，很显然这里不能调用<code>findOne()</code>方法。</li></ul><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ul><li>由于所出现的问题，所以在<code>lygz</code>报表中调用了查询类的<code>fetchList</code>方法来取出相对应的数据。</li><li>PS: 也可以通过<code>Dao</code>层的查询语句来进行数据的获取，要注意在<code>Dao</code>里拼写<code>Sql</code>语句过多会影响数据的查询速度。<br><code>fetchDate</code>返回的数据为<code>JSON</code>格式。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li><code>findById</code> 通过<code>id</code>查找,没查询到就返回<code>null</code></li><li><code>getOne</code> 通过<code>id</code>查找 采用懒加载 使用时才真正去查库.若<code>id</code>未查询到会异常<code>EntityNotFoundException</code>.</li><li><code>findOne</code>所查询的结果必须是只包含一条结果,否则会报如下异常<pre class="line-numbers language-none"><code class="language-none">org.springframework.dao.IncorrectResultSizeDataAccessException: query did not return a unique result: 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>findAllById</code> 通过<code>id</code>查询多个 若未查询到则返回空集合</li><li><code>findAllById</code> 通过<code>id</code>查询多个 若未查询到则返回空集合</li><li><code>save</code> 保存 需要配置主键自增策略 <code>@Transactional</code>注解要去掉不然会回滚数据添加失败!</li><li><code> delete</code> 删除 删除没有返回值</li><li><code>deleteALL</code> 删除所有数据 会执行两条<code>sql</code> 先查出所有<code>id</code> 然后根据<code>id</code>一条条的删除.慎用避免使用无参清空数据</li><li><code>count</code> 查询数量 无参的方法会返回所有的记录</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 需求，学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中 Boolean 和 boolean的区别</title>
      <link href="/2022/11/12/boolean-yu-boolean-de-qu-bie/"/>
      <url>/2022/11/12/boolean-yu-boolean-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中-Boolean-和-boolean的区别"><a href="#Java-中-Boolean-和-boolean的区别" class="headerlink" title="Java 中 Boolean 和 boolean的区别"></a>Java 中 Boolean 和 boolean的区别</h1><hr><h2 id="开发过程中遇到的问题"><a href="#开发过程中遇到的问题" class="headerlink" title="开发过程中遇到的问题"></a>开发过程中遇到的问题</h2><!-- ![](./Boolean%E4%B8%8Eboolean%E7%9A%84%E5%8C%BA%E5%88%AB/1.png) --><pre class="line-numbers language-none"><code class="language-none">/***** * 是否进行规格修改 */    private Boolean ischangespec=false;public Boolean getIschangespec() {return ischangespec;}public void setIschangespec(Boolean ischangespec) {this.ischangespec = ischangespec;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增加以上字段之后，经过改轧的数据不会在生产明细中显示。</p><hr><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><ul><li><code>boolean</code> 是 <code>Java</code> 的基本数据类型，<code>Boolean</code> 是 <code>Java</code> 的一个类。<code>boolean</code> 类型会在<code>“赋零值”</code>阶段给属性赋 <code>false</code>。而 <code>Boolean</code> 是一个类，会在<code>“赋零值”</code>阶段给对象赋 <code>null</code>。如果是静态属性，会在类加载时被赋值。如果是普通类属性，会在实例化对象时赋值。</li><li>简单的来说，如果<code>Boolean</code>不设置默认值那么其默认为<code>空</code>。如果<code>boolean</code>不设置默认值那么其默认为<code>false</code></li></ul><h3 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h3><ul><li>加载：根据类的全名获取类的二进制字节流，将类加载进内存并在堆中生成一个代表这个类的 <code>Class</code> 对象，作为方法区数据的访问入口。</li><li>验证：验证 <code>class</code> 文件中的字节流是否符合 <code>JVM</code> 规范。</li><li>准备：在方法区中为类的静态属性分配内存，并初始化默认值（<code>boolean </code>的默认值是 <code>false</code>，<code>Boolean </code>的默认值是 <code>null</code>）。</li><li>解析：将常量池中的符号引用转化为直接引用，可以理解为对象引用转成指针。</li><li>初始化：真正开始执行类中的代码，静态属性赋值和静态块。</li></ul><h3 id="对象实例化过程："><a href="#对象实例化过程：" class="headerlink" title="对象实例化过程："></a>对象实例化过程：</h3><ul><li>检查类是否已经被加载（双亲委派）</li><li>给对象分配内存空间（指针碰撞）</li><li>零值初始化（<code>false / null</code>）</li><li>设置对象头（对象分代年龄等信息）</li><li>执行<code>&lt;init&gt;</code>方法（属性初始化，语句块和构造方法）<br>所以说，<code>Boolean</code>只是被加载了，还没有被实例化，在被实例化之前并没有分配内存，所以是 <code>null</code></li></ul><h3 id="风险点："><a href="#风险点：" class="headerlink" title="风险点："></a>风险点：</h3><img src="https://img-blog.csdnimg.cn/20200513232440432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21raWlfaG9uZw==,size_16,color_FFFFFF,t_70#pic_center"><hr><h2 id="解决问题措施："><a href="#解决问题措施：" class="headerlink" title="解决问题措施："></a>解决问题措施：</h2><ul><li>将<code>ischangespec</code>  字段的默认值删掉，默认值为<code>null</code>。</li><li>将默认值删掉之后，重启项目发现生产明细中不能显示的数据可以正常显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java，学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab解决报错1</title>
      <link href="/2022/11/10/gitlab-jie-jue-bao-cuo-1/"/>
      <url>/2022/11/10/gitlab-jie-jue-bao-cuo-1/</url>
      
        <content type="html"><![CDATA[<h1 id="gitlab报错"><a href="#gitlab报错" class="headerlink" title="gitlab报错"></a>gitlab报错</h1><hr><h2 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h2><p><img src="/2022/11/10/gitlab-jie-jue-bao-cuo-1/1.png"></p><!-- <img src="gitlab解决报错1/日志分析.png"> --><hr><h3 id="分析错误原因"><a href="#分析错误原因" class="headerlink" title="分析错误原因"></a>分析错误原因</h3><p>根据日志可以分析出来，在我进行<code>thirdproduct</code>项目向<code>master</code>合并之前，其他同事已经提交过一次项目了，但在我提交之前没有重新拉取该项目，导致流水线在跑的时候在我的项目中找不到对应的方法所以报错。</p><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><p>查找到错误出现的原因之后得出，我<code>远端</code>的<code>practice</code>和<code>master</code>中的代码不一致，所以要拉取<code>master</code>的最新代码对<code>本地practice</code>进行更新，然后将更新之后的<code>practice</code>推送至<code>远端</code>的<code>practice</code>，这样远端提交过得 <code>practice</code>分支里边的代码就和<code>master</code>中的代码一致了，然后再进行<code>retry</code>。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/10/gitlab-jie-jue-bao-cuo-1/2.png"></h2><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ul><li>我本次提交的为<code>dlx</code>的标签上的修改，文件为<code>html</code>文件，所以在<code>pre</code>流水线跑完报错之后，<code>“合并”</code>按钮是红色的，不是灰色的，这是因为我所提交的不是业务代码，所以允许被<code>强制提交</code>，但是<code>不可以</code>进行强制提交。</li><li>注意进行推送的时候，一定要清楚地知道<code>“为什么要推送”</code>，这次我推送的原因是为了更新远端的<code>practice</code>，所以选择<code>practice</code>。若是选择<code>master</code>则会覆盖<code>远端master</code>的代码。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> gitlab，学习，报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.31-11.4周记</title>
      <link href="/2022/11/07/10-31-11-4-zhou-ji/"/>
      <url>/2022/11/07/10-31-11-4-zhou-ji/</url>
      
        <content type="html"><![CDATA[<p>总结：这一周的感觉是比较充实的，包括功能的设计、功能的bug修改以及关于dlx、ct标签的设计相关的知识都学习到了很多。<br>第一，要注意的是在设计相关报表或者功能实现的前提之下一定是要跟用户沟通清楚流程是怎样的，数据是应该怎么样去获取的，开发的过程中如果遇到了什么流程或者相关字段取值的问题一定要以和用户沟通为主。这次的lygztjbb就做的不是很好，其实当用户在修改gg里进行改动的时候就已经算是gz了，在proplan里对应的typeid=4其实可以叫做该规，那我对应的取值逻辑的主次就搞反了，后者的sql语句是正确的。<br>       1.select lz.* from  proplan pro<br>left JOIN lzproductiondetail lz on  lz.proplanid=pro.id<br>where pro.producttypeid=4<br>        2.select lz.* from  lzproductiondetail lz<br>left JOIN proplan pro on  lz.proplanid=pro.id<br>where lz.ischangespec=1<br>第二，在开发中遇到了几次空指针的问题，有的较为简单，只需要加一个判空就可以解决。但是有部分问题时调用了其他方法造成的，那么控制台的报错就会出现在对应的方法上，这个时候就要去梳理清楚逻辑，确定这个方法调用的字段有没有可能存在“空”的情况，如果存在那么加上判空条件，注意一下某个字段的取值可能有几个字段组成的，那么就要考虑这几个字段是否为空，必要的时候要加上一个&amp;&amp;。比如在StorageAndLableService中，在获取dlx——pinming和grade时，其实是调用了一个方法对这两个数据的取值又进行了转化，那么转换方法报空就是因为字段取值可能存在空的情况。<br>第三，在进行某个字段要截取取值时，一定要注意分隔符，像“+”、“*”等这种符号是会出现在正则表达式里的，解决方法就是要加一个“/”或者“[]”。<br>第四，要注意在本地数据库里出现某字段数据id存在，但对应字段数据不存在时，可以去只读的正式数据库里进行查找，若正式数据库里存在数据，那么就要把它insert到本地数据库里，这里要注意，insert到本地的数据库为中台本地数据库，比如goodsCode这个字段，因为项目的数据查询是要去调取dubbo的。<br>第五，学习到了mobile端打包升级的知识，需要注意：1.终端中的powershell要换成wsl，因为我们是要通过wsl进行打包。2.右下角的行尾序列要将CRLF换成LF。3.app.compotent.ts line:34中有个login，打包为apk时要放开，打包web时要注掉。打包语句举例：“./app-update.sh test”。前端的打包涉及到了Linux语句，要对Linux基础知识学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习、需求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/07/hello-world/"/>
      <url>/2022/11/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
